#  word_break
**判断字符串s是否是由wordDict中的word组成，wordDict中的word可以被用多次**
**dp[i]表示以i结尾的字符串可否满足上述条件，dp[i]为true的条件是：j ->[0, i-1]中   dp[j] && s.substr(j, i-j)在wordDict中出现**

``` cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> dict(wordDict.begin(), wordDict.end());
        vector<int> dp(s.size()+1);
        dp[0] = 1;
        for(int i = 1; i <= s.size(); i++) {
            for (int j = i-1; j >= 0; j--) {
                if (dp[j] && dict.find(s.substr(j, i-j)) != dict.end())
                {
                    dp[i] = 1;
                    break;
                }
            }
        }
        return dp[s.size()];
    }
};
```

# word break ii

**回溯法+备忘录可以解决**

``` cpp
Example 1:
Input:
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
Output:
[
  "cats and dog",
  "cat sand dog"
]

Example 2:
Input:
s = "pineapplepenapple"
wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
Output:
[
  "pine apple pen apple",
  "pineapple pen apple",
  "pine applepen apple"
]
Explanation: Note that you are allowed to reuse a dictionary word.

Example 3:
Input:
s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]
Output:
[]
```

**思路：采用backstrace，可以完成，但是超时**
``` cpp
class Solution {
public:
    vector<string> wordBreak(string s, vector<string>& wordDict) {
        if (s.empty()) return vector<string>();
        vector<string> result;
        if (find(wordDict.begin(), wordDict.end(), s) != wordDict.end())
            result.push_back(s);
        for (int i = 1; i <= s.size(); i++) {
            string left = s.substr(0, i);
            if (find(wordDict.begin(), wordDict.end(), left) != wordDict.end()) {
                string right = s.substr(i);
                vector<string> next = wordBreak(right, wordDict);
                
                for (auto str : next) {  
                    result.push_back(left + " " + str);    
                }
            }
        }
        
        return result;
    }
};
```
**优化**
``` cpp
class Solution {
private:
    std::unordered_map<string, vector<string>> cache;
public:
    vector<string> wordBreak(string s, vector<string>& wordDict) { 
        if (s.empty()) return {""};
        if (cache.find(s) != cache.end()) return cache[s];
        vector<string> result;
        for (auto& str : wordDict) {
            if (s.substr(0, str.size()) != str) continue;
            vector<string> res = wordBreak(s.substr(str.size()), wordDict);
            for (auto& r : res) {
                result.push_back(str+(r.empty()?"":" ")+r);
            }
        } 
        cache[s] = result;
        return result;
    }
};
```

# wiggle subsequence

```cpp
Example 1:
Input: [1,7,4,9,2,5]
Output: 6
Explanation: The entire sequence is a wiggle sequence.

Example 2:
Input: [1,17,5,10,13,15,10,5,16,8]
Output: 7
Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].

Example 3:
Input: [1,2,3,4,5,6,7,8,9]
Output: 2
```

**思路：dp解决，up[i]记录到i为止,i>i-1时满足条件的序列长度，down[i]记录到i为止i<i-1时满足条件的序列长度**

| -    | 2    | 1    | 2    | 3    | 4    | 3    | 2    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| up   | 1    | 1    | 3    | 3    | 3    | 3    | 3    | 3    |
| down | 1    | 2    | 2    | 2    | 2    | 4    | 4    | 4    |

**这俨然已经成为了一个dp问题，不过需要对上述两种情况都需要算**

- 因为计算dp[i]时有两种可能
  - i > i-1，说明目前处在上身阶段，那么i的最长长度一定为到 i-1 处于下降阶段的数值+1
  - i < i-1，与上述情况相反

```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.empty()) return 0;
        vector<int> up(nums.size());
        vector<int> down(nums.size());
        up[0] = 1;
        down[0] = 1;  
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > nums[i-1]) {
                up[i] = down[i-1] + 1;
                down[i] = down[i-1];
            } else if (nums[i] < nums[i-1]) {
                down[i] = up[i-1] + 1;
                up[i] = up[i-1];
            } else {
                down[i] = down[i-1];
                up[i] = up[i-1];
            }
        }
        return max(up[nums.size()-1], down[nums.size()-1]);
    }
};
```

# unique binary search trees

**递归问题，以i为根节点，那么其左子树[1, i-1]，右子树[i+1, end]，同理递归，当sstart > end时，返回1**

``` cpp
class Solution {
public:
	int numTrees(int n) {
		dp.resize(n+1);
		for (int i = 0; i < n+1; ++i) {
			dp[i].resize(n+1);
		}
		return recur(1, n);
	}

	int recur(int start, int end) {

		if (start > end) return 1;

		int left = 0;
		int right = 0;

		if (dp[start][end] != 0) return dp[start][end];

		for (int i = start; i <= end; i++) {

			left = recur(start, i - 1);
			right = recur(i + 1, end);
			dp[start][end] += (left*right);
		}
		return dp[start][end];
	}

private:
	std::vector<std::vector<int>> dp;
};

```

# unique string in wraparound string

- 统计p中独一无二字符串的个数， p[i] == p[i-1]+1 || i == 0
``` cpp
class Solution {
public:
    // dp: dp[i]表示以p[i]结尾的满足条件的个数
    int findSubstringInWraproundString(string p) {
        vector<int> dp(26 , 0);
        int maxLength = 0;
        for (int i = 0; i < p.size(); i++) {
            if (i > 0 && (p[i] - p[i-1] == 1 || p[i-1]-p[i] == 25)) {
                maxLength++;
            } else {
                maxLength = 1;
            }
            dp[p[i]-'a'] = max(maxLength, dp[p[i]-'a']);
        }
        int ans = 0;
        for (int i = 0; i < dp.size(); i++) ans += dp[i];
        return ans;
    }
};
```
# unique path

``` cpp
Example 1:
Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Right -> Down
2. Right -> Down -> Right
3. Down -> Right -> Right
4. 
Example 2:
Input: m = 7, n = 3
Output: 28
```

- dfs + memory
``` cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        cache.resize(m+1);
        for (auto& c : cache) c.resize(n+1, -1);
        return dfs(1, 1, m, n);
    }
    
    int dfs(int i, int j, int m, int n) {
        if (i == m && j == n) {
            return 1;
        }
        if (i > m || j > n) {
            return 0;
        }
        if (cache[i][j] >= 0) return cache[i][j];
        int cnt = dfs(i+1, j, m, n) + dfs(i, j+1, m, n);
        cache[i][j] = cnt;
        return cnt;
    }
    
    vector<vector<int>> cache;
};
```

- dp
``` cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        return dp(m, n);
    }
    
    int dp(int m, int n) {
        vector<vector<int>> dp(m+1, vector<int>(n+1));
        dp[0][1] = 1;
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m][n];
        
    }
};
```

# unique path ii
``` cpp
class Solution {
public:
	int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
		x_bound = obstacleGrid.size() - 1;
		y_bound = obstacleGrid[0].size() - 1;
		//		int count = recur(0, 0, obstacleGrid);
		int count = dp3(x_bound + 1, y_bound + 1, obstacleGrid);
		return count;
	}
private:
	int dp1(int x, int y, vector<vector<int>>& obstacleGrid) {
		vector<vector<int>> dp(x, vector<int>(y, 0));
		dp[0][0] = obstacleGrid[0][0] == 0 ? 1 : 0;
		for (int i = 1; i < dp.size(); i++) {
			dp[i][0] = (obstacleGrid[i][0] == 0 ? dp[i - 1][0] : 0);
		}
		for (int j = 1; j < dp[0].size(); j++) {
			dp[0][j] = (obstacleGrid[0][j] == 0 ? dp[0][j - 1] : 0);
		}
		for (int i = 1; i < dp.size(); i++) {
			for (int j = 1; j < dp[0].size(); j++) {
				if (obstacleGrid[i][j] == 0) {
					dp[i][j] += (dp[i - 1][j] + dp[i][j - 1]);
				}
				else {
					dp[i][j] = 0;
				}
			}
		}
		return dp[dp.size() - 1][dp[0].size() - 1];
	}

	int dp2(int x, int y, vector<vector<int>>& obstacleGrid) {
		vector<int> dp(y, 0);
		dp[0] = obstacleGrid[0][0] == 1 ? 0 : 1;
		for (int i = 1; i < obstacleGrid[0].size(); i++) {
			dp[i] = obstacleGrid[0][i] == 1 ? 0 : dp[i-1];
		}
		for (int i = 1; i < obstacleGrid.size(); i++) {
			dp[0] = obstacleGrid[i][0] == 1 ? 0 : dp[0];
			for (int j = 1; j < obstacleGrid[0].size(); j++) {
				if (obstacleGrid[i][j] == 0) {
					dp[j] += dp[j - 1];
				}
				else {
					dp[j] = 0;
				}
			}
		}

		return dp[dp.size()-1];
	}
 
    	int dp3(int x, int y, vector<vector<int>>& obstacleGrid) {
		vector<int> dp(y, 0);
		dp[0] = obstacleGrid[0][0] == 1 ? 0 : 1;
		
		for (int i = 0; i < obstacleGrid.size(); i++) {
			for (int j = 0; j < obstacleGrid[0].size(); j++) {
				if (obstacleGrid[i][j] == 1) dp[j] = 0;
				else if (j > 0) dp[j] += dp[j - 1];
				else {

				}
			}
		}

		return dp.back();
	}
    
	int recur(int x, int y, vector<vector<int>>& obstacleGrid) {
		if (x > x_bound || y > y_bound || obstacleGrid[x][y] == 1) {
			return 0;
		}

		if (x == x_bound && y == y_bound) {
			return 1;
		}
		return recur(x + 1, y, obstacleGrid) + recur(x, y + 1, obstacleGrid);
	}
private:
	int x_bound;
	int y_bound;
};
```

# burst balloons
- 自顶向下的递归实现

```
思路1：选取[i, j]之间的一个k点作为爆炸点，那么将产生[i,k-1] [k+1,j]两个子问题，d[i][j] = d[i][k-1] + d[k+1][j] + nums[k]*nums[k-1]*nums[k+1]，这种思路存在的问题，爆破之后，两个子问题会相互关联，所以不可取

思路2：选取[i, j]之间的一个k点作为最后的爆炸点，那么原问题变为求解[i,k-1]，[k+1][j]两个子问题的最优解，因为k作为最后爆炸点，所以[i,k-1]，[k+1, j]不会互相影响，满足最优子结构要求，d[i][j] = d[i][k-1] + d[k+1][j] + nums[i-1]*nums[k]*nums[j+1]
```

``` cpp
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        nums.insert(nums.begin(), 1);
        nums.insert(nums.end(), 1);
        mem.resize(nums.size());
        for (auto& m : mem) {
            m.resize(nums.size(), 0);
        }
        return divide(nums, 1, nums.size() - 2);
    }
    
    int divide(vector<int>& nums, int left, int right) {
        if (left > right) return 0;
        if (mem[left][right] != 0) return mem[left][right];
        int ret = INT_MIN;
        for (int i = left; i <= right; i++) {
            ret = max(divide(nums, left ,i-1)+divide(nums, i+1, right)+nums[left-1]*nums[right+1]*nums[i], ret);
        }
        mem[left][right] = ret;
        return ret;
    }
    
    std::vector<vector<int>> mem;
};
```

- 自底向上 递推公式如自顶向下

``` cpp
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        nums.insert(nums.begin(), 1);
        nums.insert(nums.end(), 1);
        std::vector<vector<int>> dp(nums.size(), vector<int>(nums.size(), 0));
        
        for (int len = 1; len < nums.size(); len++) {
            for (int i = 1; i < nums.size() - len; i++) {
                int j = i + len - 1;
                int m = INT_MIN;
                for (int k = i; k <= j; k++) {
                    m = max(m, dp[i][k-1] + dp[k+1][j] + nums[i-1]*nums[j+1]*nums[k]);
                }
                dp[i][j] = m;
            }
        }
        return dp[1][nums.size()-2];
    }  
};
```

# edit distance
**思路：自顶向下的dp方式，从大问题开始考虑**
``` cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        mem.resize(word1.size());
        for (auto& m : mem) m.resize(word2.size(), -1);
        return dfs(word1, word2, 0, 0);
    }
    
    int dfs(const string& word1, const string& word2, int i, int j) {
        if (j == word2.size() && i == word1.size()) {
            return 0;
        }
        if (i == word1.size()) {
            return word2.size()-j;   // 添加word2剩余的字符
        }
        if (j == word2.size()) {
            return word1.size()-i; // 删除word1剩余的字符
        }
        
        if (mem[i][j] != -1) return mem[i][j];
        
        int m = INT_MAX;
        if (word1[i] == word2[j]) {
            m = dfs(word1, word2, i+1, j+1);
        } else {
            int r = dfs(word1, word2, i+1, j+1);// 替换字符word1[i]为word2[j]
            int d = dfs(word1, word2, i+1, j);  // 删除字符word1[i]
            int a = dfs(word1, word2, i, j+1);  // 添加字符word2[j]
            m = min(min(r, d), a) + 1;
        }
        mem[i][j] = m;
        return m;
    }
    
    vector<vector<int>> mem;
};
```

# out of boundary paths
![](https://assets.leetcode.com/uploads/2018/10/13/out_of_boundary_paths_1.png)
![](https://assets.leetcode.com/uploads/2018/10/12/out_of_boundary_paths_2.png)

- 自顶向下的递归+备忘录

``` cpp
class Solution1 {
public:
    int findPaths(int m, int n, int N, int i, int j) {
        vector<vector<vector<int>>> memo(N+1, vector<vector<int>>(m, vector<int>(n, -1)));    
        return dfs(m, n, N, i, j, memo);
    }
    
    int dfs(int m, int n, int N, int i, int j, vector<vector<vector<int>>>& memo) {
        if ((i < 0 || i == m || j < 0 || j == n)) {
            return 1;
        }
        if (0 == N) return 0;
        if (memo[N][i][j] != -1) return memo[N][i][j];
        
        memo[N][i][j] = ((dfs(m, n, N-1, i+1, j, memo)+dfs(m, n, N-1, i-1, j, memo))%M + (dfs(m, n, N-1, i, j+1, memo) + dfs(m, n, N-1, i, j-1, memo))%M)%M;
        
        return memo[N][i][j];
    }
    static const int M = 1000000007;
    
};
```


- 自顶向下的递归+备忘录
- dp[ni][i][j] = dp[ni-1][i-1][j] + dp[ni-1][i][j-1] + dp[ni-1][i+1][j] + dp[ni-1][i][j++1];

``` cpp
class Solution {
public:
    int findPaths(int m, int n, int N, int i, int j) {
        vector<vector<vector<int>>> dp(N+1, vector<vector<int>>(m, vector<int>(n, 0)));
        for (int ni = 1; ni <= N; ni++) {
            for (int mi = 0; mi < m; mi++) {
                for (int mj = 0; mj < n; mj++) {
                    int ans1 = mi == 0 ? 1 : dp[ni-1][mi-1][mj];
                    int ans2 = mj == 0 ? 1 : dp[ni-1][mi][mj-1];
                    int ans3 = mi == m-1 ? 1 : dp[ni-1][mi+1][mj];
                    int ans4 = mj == n-1 ? 1 : dp[ni-1][mi][mj+1];
                    dp[ni][mi][mj] = ((ans1 + ans2)%M + (ans3+ans4)%M)%M;
                }
            }
        }
        return dp[N][i][j];
    }
    static const int M = 1000000007;
};
```

# knight probability in chessboard
**在一个N*N的矩阵中，一个knight在(r, c)位置处，每次knigh可以向8个方向分别走马字形，问K此移动之后，knight依旧在chessboard上概率**

- 自顶向下的memo方法

``` cpp
class Solution {
public:
    double knightProbability(int N, int K, int r, int c) { 
        vector<vector<int>> dir = {{1, 2}, {1, -2}, {-1, 2}, {-1, -2}, {2, 1}, {2, -1}, {-2 ,1}, {-2, -1}};
        for (int i = 0; i <= K; i++) {
            for (int j = 0; j < N; j++) {
                for (int z = 0; z < N; z++) {
                    dp[i][j][z] = -1.0f;
                }
            }
        }
        return dfs(N, K, r, c, dir);
    }
    
    double dfs(int N, int K, int r, int c, vector<vector<int>>& dir) {
        if (r >= N || r < 0 || c >= N || c < 0) {
            return 0.0f;
        }
        if (K == 0) {
            return 1.0f;
        }
        if (dp[K][r][c] >= 0) return dp[K][r][c];
        double ret = 0.0f;
        for (int i = 0; i < 8; i++) {
            ret += dfs(N, K-1, r + dir[i][0], c + dir[i][1], dir);
        }
        ret /= 8.0;
        dp[K][r][c] = ret;
        return ret;
    }
    double dp[101][25][25];
};
```

# concatenaed words

给定一个字符串数组，如果某个字符串是由该数组中的两个或两个以上的字符串组成的话那么称作concatenaed word，求出所有的concatenaed words。

- 回溯法，stackoverflow

``` cpp
class Solution1 {
public:
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        vector<string> ans;
        for (int i = 0; i < words.size(); i++) {
            if (backstrace(words, i, words[i])) ans.push_back(words[i]); 
        } 
        return ans;
    }
    
    bool backstrace(vector<string>& words, int index, string src) {
        if (src.empty()) {
            return true;
        }
        bool ret = false;
        for (int i = 0; i < words.size(); i++) {
            if (index == i) continue;
            
            string str1 = src.substr(0, words[i].size());
            if (src.size() < words[i].size()) continue;
            if (str1 != words[i]) continue;
            
            ret = backstrace(words, index, src.substr(str1.size()));
        }
        return ret;
    }
};
```

- 先排序，然后只在word之前的words里面找

``` cpp
class Solution2 {
public:
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        vector<string> ans;
        sort(words.begin(), words.end(), [](auto& lhs, auto& rhs){return lhs.size() < rhs.size();});        
        unordered_set<string> s;
        for (auto& word : words) {
            if (dfs(s, word, "", 0)) ans.push_back(word);
            else s.insert(word);   //else 是一个优化，归纳法得证
        }  
        return ans;
    }
    bool dfs(const unordered_set<string>& s, const string& word, string path, int i) {
        if (s.empty()) return false;
        
        if (i == word.size()) {
            if (s.count(path)) return true;
            return false;
        }
        
        path.push_back(word[i]);
        bool ret = false;
        if (s.count(path)) {
            ret |= dfs(s, word, "", i+1);
        }
        if (!ret)
            ret |= dfs(s, word, path, i+1);
        
        return ret;
    } 
};
```

- 动态规划方法
``` cpp
class Solution {
public:
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        vector<string> ans;     
        sort(words.begin(), words.end(), [](auto& lhs, auto& rhs){return lhs.size() < rhs.size();});
        unordered_set<string> s;
        for (auto& word : words) {
            if (dp(s, word)) ans.push_back(word);
            else s.insert(word);   //else 是一个优化，归纳法得证
        }    
        return ans;
    }    
    
    bool dp(const unordered_set<string>& s, const string& word) {
        if (word.empty() || s.empty()) return false;
        vector<int> dp(word.size()+1);
        dp[0]  = 1;
        for (int i = 1; i <= word.size(); i++) {
            for (int j = i-1; j >= 0; j--) {
                
                if (dp[j] && s.count(word.substr(j, i-j))) {
                    dp[i] = 1;
                    break;
                }
            }
        }
        return dp[word.size()];
    }
};
```

# target sum
```
Example 1:
Input: nums is [1, 1, 1, 1, 1], S is 3. 
Output: 5
Explanation: 

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

There are 5 ways to assign symbols to make the sum of nums be target 3.
```
- 暴力解决   O(2^n)
``` cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        return dfs(nums, 0, 0, S);
    }
    
    int dfs(vector<int>& nums, int i, int sum, int S) {
        if (i == nums.size()) {
            return sum == S;
        }
        return dfs(nums, i+1, sum+nums[i], S) + dfs(nums, i+1, sum-nums[i], S);
    }
};
```
- 动态规划解决
  dp[i][j]表示的是第i个物体，sum=j的数量
  dp[i][j] = dp[i-1][j+nums[i]] + dp[i-1][j-nums[i]]
  由于j的范围是从-sum---+sum，等价于0---2*sum
  对dfs方式进行一个直接的转换, dp[i+1][j] = dp[i][j+nums[i]] + dp[i][j-nums[i]]
``` cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        return dp(nums, S);
    }
    
    int dp(vector<int>& nums, int S) {
        int sum = 0;
        for (auto& n : nums) {
            sum += n;
        }
        if (S > sum || S < -sum) return 0;
        vector<vector<int>> v(nums.size()+1, vector<int>(2*sum+1));
        v[0][sum] = 1;
        for (int i = 1; i <= nums.size(); i++) {
            for (int j = 0; j <= 2*sum; j++) {
                if (j - nums[i-1] >= 0) v[i][j] += v[i-1][j-nums[i-1]];
                if (j + nums[i-1] <= 2*sum) v[i][j] += v[i-1][j+nums[i-1]];
            }
        }
        return v[nums.size()][sum+S];
    }
};
```

# stone-game
**只能从左右两边取数字，两人都足够聪明，贪心解决不了问题。例如[5 1 7 6]**
**动态规划解决**

- 动态规划问题：选择了piles[i]，相当于求解piles[i+1,..j]这个子问题，或者选择了piles[j]，相当于求解piles[i,..j-1]这个子问题
- 当j=i+1时，dp[i] [j] = max(piles[i] - dp[i+1] [j], piles[j] - dp[i] [j-1])
- 所以 dp[i] [j] = max(piles[i] - dp[i+1] [j], piles[j] - dp[i] [j-1])
- dp[i] [j]表示i, j段内的最大差值
``` cpp
class Solution {
public:
    bool stoneGame(vector<int>& piles) {
        vector<vector<int>> dp (piles.size(), vector<int>(piles.size()));
        for (int i = 0; i < piles.size(); i++) {
            dp[i][i] = piles[i];
        }
        
        for (int len = 1; len < piles.size(); len++) {
            for (int i = 0; i < piles.size()-len; i++) {
                dp[i][i+len] = max(piles[i] - dp[i+1][i+len], piles[i+len] - dp[i][i+len-1]);
            }
        }
        return dp[0][piles.size()-1];
    }
};
```

# maximum product subarray
- 记录index之前的最大值以及最小值，如果当前index为负值，则当前index的最大值为
- index*min，否则index*max，由于是题目要求是子数组，所有index之前的最大值为
- max(max_pre_index * index, min_pre_index*index, index)，最小值为 min(min_pre_index*index, max_pre_index*index, index);

``` cpp
class Solution {
public:
	int maxProduct(vector<int>& nums) {
		int min{ nums[0] };
		int max{ min };
		int res{ min };
		for (int i = 1; i < nums.size(); i++) {
            int tmp_max = max;
			max = std::max( std::max(max*nums[i], nums[i]), std::max(min*nums[i], nums[i]));
			min = std::min(std::min(tmp_max*nums[i], nums[i]), std::min(min*nums[i], nums[i]));

			res = std::max(max, res);
		}

		return res;
	}
};
```

# longest palindromic substring

**回文子序列个数： dp[i] [j] = dp[i+1] [j]+dp[i] [j-1]-dp[i+1] [j-1] (if str[i] != str[j])**
**				dp[i] [j] = dp[i+1] [j]+dp[i] [j-1]-dp[i+1] [j-1] + dp[i+1] [j-1]+1 (if str[i] == str[j])**

**解析：**
- 当str[i] != str[j]时，那么dp[i] [j] = dp[i+1] [j]+dp[i] [j-1]-dp[i+1] [j-1]，减去dp[i+1] [j-1]的原因是dp[i+1][j]和dp[i] [j-1]会对dp[i+1] [j-1]重复计算
- 当str[i] == str[j]时候，dp[i] [j] = dp[i+1] [j]+dp[i] [j-1]-dp[i+1] [j-1]+dp[i+1] [j-1]+1，加上dp[i+1] [j-1]的原因是由于str[i]==str[j]，所以在dp[i+1] [j-1]内的所有回文子序列两端扩充str[i]和str[j]一定也是回文子序列，+1的原因是：str[i]..str[j]也是回文子序列

``` cpp
Example 1:
Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.

Example 2:
Input: "cbbd"
Output: "bb"
```

- 法1：动态规划
``` cpp
class Solution {
public:
    /*
    * 对于回文字符串来说：
	* 1. 含有单个字符的字符串必定是回文字符串，例如 a。
	* 2. 含有两个字符的字符串 aa是回文字符串。
	* 3. 含有三个字符的字符串 aba 只要s[0] == s[2]，即一定是回文字符串。
	* 4. 含有四个字符的字符串 abba 只要w(1,2)是回文字符串且s[0] == s[3]，即一定是回文字符串。
    * 即子问题为：w(i,j)为回文字符串，当且仅当w(i+1,j-1)是回文字符串，且s[i] == s[j]。
    * 最优解结构为         
    *             true             	i == j              		 
    * w(i,j)      true         		j == i+1 && s[i] == s[j]  	      	
    *             w(i+1, j - 1) && s[i] == s[j] j > i+1                 
    */
    
    string longestPalindrome(string s) {
        int size = s.size();
        //空字符串无回文串
        if(size == 0) {
            return "";
        }
        //定义一个适当容量的dp
        vector <vector<bool> > dp;
        dp.resize(size, vector<bool>(size));
        GetDp(s, dp);
        return GetStrFromDp(s, dp);
    }
    
    void GetDp(string str, vector<vector<bool> > &dp) {      
        int strSize  = str.size(); 
        //对dp的初始化
        for(int i = 0; i < strSize; i++) {
            //1.一个字符必定为回文串
            dp[i][i] = true;
            //2.两个字符，若相等，则必为回文串
            if(str[i] == str[i+1]) {
                dp[i][i+1] = true;
            }                                        
        }
        
        //3.j > i + 1的情况
        for(int len = 3; len <= strSize; len++) {  
            //确定结束位置
            int end = strSize - len + 1;
            int j = 0;
            for(int i = 0; i < end; i++) {
                //j代表右端位置
                j = i + len - 1;
                if(str[i] == str[j] && dp[i+1][j - 1]) dp[i][j] = true;
            }
        }   
    }
    
    string GetStrFromDp(string str, const vector<vector<bool> > &dp) {
        //记录回文串起始下标索引
        int maxLen = 0, maxEnd = 0;
        int size = str.size();
        //i表示起始下标，j表示结束下标
        for(int i = 0; i < size; i++) {
            //dp是一个上三角矩阵
            for(int j = i; j < size; j++) { 
                if(dp[i][j] && ((j - i + 1) > maxLen)) { 
                    maxLen = j - i + 1;
                    maxEnd = j;
                }
            }
        }     
        int start = maxEnd + 1 - maxLen;
        string strRes = str.substr(start,maxLen);
        return strRes;
    }
  
};
```

- 法2：manacher
``` cpp
class Solution {
public:
	string longestPalindrome(string str) {
        int size = str.size();
		if(size == 0) return "";
		return Manacher(str);
	}
	string Manacher(string str) {	
		//构造manacher算法所需要的字符串
		int size = str.size();
		string dst(2 * size + 1, '0');
		ExpandString(str, dst);
		int index = -1, rightPos = -1, maxLen = -65532, maxIndex;
		size = dst.size();
		vector<int> maxRadiusVec(size);
		//i+maxRadiusVec[i]代表最右端能够到达的位置，i-maxRadiusVec[i]代表最左端能够到达的位置。
		for(int i = 0; i < size; i++) {
			//如果最右端即将到达的位置已经包含了当前位置i，则可以加速。
			maxRadiusVec[i] = (rightPos > i ? MIN(maxRadiusVec[index * 2 - i], rightPos - i) : 1);
			//正常扩张
			while(i + maxRadiusVec[i] < size && i - maxRadiusVec[i] > -1) {
				if(dst[i + maxRadiusVec[i]] == dst[i - maxRadiusVec[i]]) maxRadiusVec[i]+=1;
				else break;
			}
			//更新rightPos和index
			if(i+maxRadiusVec[i] > rightPos) {
				rightPos = i + maxRadiusVec[i];
				index = i;
               
			}
			maxLen    = max(maxRadiusVec[i], maxLen);
		}
		for(int i = 0; i < size; i++) {
			if(maxRadiusVec[i] == maxLen) {		
				maxIndex = i;
				break;
			}
		}
		string res = dst.substr(maxIndex - maxLen + 1, 2 *( maxIndex - (maxIndex - maxLen + 1)))
		res.erase(remove(res.begin(), res.end(), '#'), res.end());
		return res;
	}

	void ExpandString(string &src, string &dst) {
		int size = dst.size();
		int index = 0;
		for(int i = 0; i < size; i++) {
			dst[i] = (i & 1) == 0 ? '#' : src[index++];
		} 
	}
};
```

# predict the winner
``` cpp
Example 1:
Input: [1, 5, 2]
Output: False
Explanation: Initially, player 1 can choose between 1 and 2. 
If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). 
So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. 
Hence, player 1 will never be the winner and you need to return False.
```

![](https://leetcode.com/problems/predict-the-winner/Figures/486/486_Predict_the_winner_new.PNG)

- 法一，利用如上图所示的方法进行dfs
``` cpp
class Solution {
public:
    bool PredictTheWinner(vector<int>& nums) {
        //return dfs(nums, 0, nums.size()-1, 1) >= 0;   
        return dfs2(nums, 0, nums.size() - 1) >= 0;
    }
    
    int dfs(vector<int>& nums, int begin, int end, int turn) {
        if (begin == end) return turn*nums[begin];
        
        int a = nums[begin]*turn + dfs(nums, begin+1, end, -turn);
        int b = nums[end]*turn + dfs(nums, begin ,end-1, -turn);
        
        // player1求max，player2求min
        return turn * max(turn*a, turn*b);
    }
    
		// 法二，记录差值
    int dfs2(vector<int>& nums, int begin, int end) {
        if (begin == end) return nums[begin];
        
        int a = nums[begin] - dfs2(nums, begin+1, end);
        int b = nums[end] - dfs2(nums, begin, end-1);
        
        return max(a, b);
    }
};
```

# partition equal subset sum

**数组是否可以分成两个子数组，这两个子数组的sum相等**

**01背包问题**

``` cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = accumulate(nums.begin(), nums.end(), 0);
        
        if (sum&1) return false;
        
        return optDP(nums, sum/2);
    }
    
    // dp[i][j] = dp[i-1][j-nums[i]] || dp[i-1][j]
    bool DP(vector<int>& nums, int target) {
        vector<vector<long long>> dp(nums.size()+1, vector<long long>(target+1, 0));
        
        for (int j = 0; j <= target; j++) dp[0][j] = 0;
        for (int i = 0; i <= nums.size(); i++) dp[i][0] = 1;
        
        for (int i = 1; i <= nums.size(); i++) {
            for (long long j = 1; j <= target; j++) {
                dp[i][j] = dp[i-1][j];
                if (j-nums[i-1] >= 0)
                    dp[i][j] |= dp[i-1][j-nums[i-1]];
            }
        }
        
        return dp[nums.size()][target] > 0;
    }
    
    // dp[j] = dp[j-nums[i]] || dp[j];
    // 需要从后往前算
    bool optDP(vector<int>& nums, int target) {
        vector<int> dp(target+1, 0);
        dp[0] = 1;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = target; j - nums[i] >= 0; j--) {
                dp[j] |= dp[j-nums[i]]; 
            }
        }
        return dp[target];
    }
};
```

# palindromic substrings
- 长度为n的字符串一共有2*n-1个center
- string "1 2 3"
- center  12345
- 对于center 1而言，其left=right=0
- 对于center 2而言，其left=0，right=1
- 对于center 3而言，其left=1，right=1， 同时以3为center的字符串还包括left=0，right=2
- ...以此类推
``` cpp
class Solution {
public:

    int countSubstrings(string s) {
        const int n = s.size();
        int centerNum = 2*n-1;
        int count = 0;
        
        for (int i = 0; i <= centerNum; i++) {
            int left = i/2;
            int right = left+i%2;
            while (left >= 0 && right < n && s[left] == s[right]) {
                count++;
                left--;
                right++;
            }
        }
        return count;
    }
};

class Solution1 {
public:
    int countSubstrings(string s) {
        const int n = s.size();
        int count = 0;
        vector<vector<int>> dp(n, vector<int>(n));
        for (int d = 0; d < n; d++) {
            for (int i = 0; i+d < n; i++) {
                int j = i+d;
                if (s[i] == s[j]) {
                    dp[i][j] = (i+1>=j-1) ? true : dp[i+1][j-1];
                    if (dp[i][j]) count++;
                }
            }
        }
        return count;
    }
};
```

# maximal rectangle
``` cpp
Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.

Example:
Input:
[
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
Output: 6
```

**与largest-rectangle-in-histogram差不多，只不过需要将每一行转换成为高度而已**
``` cpp
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        if (matrix.empty()) return 0;
        vector<int> heights(matrix[0].size());
        
        
        int maxR = 0;
        
        for (int i = 0; i < matrix.size(); i++) {
            for (int j = 0; j < matrix[0].size(); j++) {
                if (matrix[i][j] == '1') {
                    heights[j] = heights[j]+1;
                } else heights[j] = 0;
            }
            
            maxR = max(maxR, largestRectangleArea(heights));
        }
        return maxR;
    }
    
    int largestRectangleArea(vector<int>& heights) {
        
        int ans = 0;
        int len = heights.size();
        vector<int> left(heights.size(), 0);
        vector<int> right(heights.size(), len-1);
        
        for (int i = 1; i < len; i++) {
            int l = i;
            while (l > 0 && heights[l-1] >= heights[i]) {
                l = left[l-1];
            }
            left[i] = l;
        }
        
        for (int i = len-2; i >= 0; i--) {
            int r = i;
            while (r < len - 1 && heights[r+1] >= heights[i]) {
                r = right[r+1];
            }
            right[i] = r;
        }
        
        for (int i = 0; i < len; i++) {
            ans = max(ans, heights[i]*(right[i]-left[i]+1));
        }
        
        return ans;
    }
};
```

# largesst rectangle in histogram
![](https://assets.leetcode.com/uploads/2018/10/12/histogram.png)
![](https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png)
**burst force**
``` cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int ans = 0;
        for (int i = 0; i < heights.size(); i++) {
            int height = heights[i];
            int l, r;
            l = r = i;
            int oldL = l, oldR = r;
            while (l >= 0 && r < heights.size()) {
                oldL = l; oldR = r;
                if (l > 0 && heights[l-1] >= height) l--;
                if (r < heights.size() - 1 && heights[r+1] >= height) r++;
                ans = max(ans, height*(r-l+1));      
                if (oldL == l && oldR == r) break;
            }
        }
        return ans;
    }
};
```

**动态规划，只需要将每一个位置的left以及right求出来即可**
``` cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        
        int ans = 0;
        int len = heights.size();
        vector<int> left(heights.size(), 0);
        vector<int> right(heights.size(), len-1);
        
        for (int i = 1; i < len; i++) {
            int l = i;
            while (l > 0 && heights[l-1] >= heights[i]) {
                l = left[l-1];
            }
            left[i] = l;
        }
        
        for (int i = len-2; i >= 0; i--) {
            int r = i;
            while (r < len - 1 && heights[r+1] >= heights[i]) {
                r = right[r+1];
            }
            right[i] = r;
        }
        
        for (int i = 0; i < len; i++) {
            ans = max(ans, heights[i]*(right[i]-left[i]+1));
        }
        
        return ans;
    }
};
```

# max area of island

**dfs，对grid[i] [j]进行四个方向的遍历，每次需要将grid[i] [j]置为0**

``` cpp
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        int ans = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    int area = dfs(grid, i, j, m, n, 0);
                    ans = max(ans, area);                    
                }

            }
        }
        return ans;
    }
    
    int dfs(vector<vector<int>>& grid, int i, int j, int m, int n, int area) {
        if (i >= m || i < 0 || j >= n || j < 0 || grid[i][j] == 0) {
            return area;
        }
        
        grid[i][j] = 0;
        
        area++;
        area = dfs(grid, i+1, j, m, n, area);
        area = dfs(grid, i-1, j, m, n, area);
        area = dfs(grid, i, j+1, m, n, area);
        area = dfs(grid, i, j-1, m, n, area);
        return area;
    }
};
```

# min cost climbing stairs

- 自顶向下  min(f(i+1), f(i+2) )+ c[i] 
- 自底向上  min(dp[i-1]+c[i-1], dp[i-2]+c[i-2])

``` cpp
class Solution {
public:
    // dp[i] = min(dp[i-1] + c[i-1], dp[i-2] + c[i-2])
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        vector<int> dp(n+1);
        
        for (int i = 2; i <= n; i++) {
            dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]);
        }
        return dp[n];
    }
};
```



# flip string to monotone increasing

**思路: 记录左边1的个数，右边0的个数，对于每一个|位置，要想单调调增，无非是将left的1的变为0，right的0变为1**

- | 0 | 0 | 1 | 1 | 0 |
- | 0 | 0 | 1 | 2 | 0 |   left
- | 3 | 2 | 1 | 1 | 1 |   right
- 0    0    0    1    2    2   left
- 3    2    1    1    1    0   right
``` cpp
class Solution {
public:

    int minFlipsMonoIncr(string S) {
        int s = S.size();
        vector<int> left(s);
        vector<int> right(s);
        
        left[0] = S[0] ==  '1' ? 1 : 0;
        right[s-1] = S[s-1] == '0' ? 1 : 0;
        
        for (int i = 1; i < s; i++) {
            left[i] = S[i] == '1' ? left[i-1] + 1 : left[i-1];
            right[s-i-1] = S[s-i-1] == '0' ? right[s-i-1+1] + 1 : right[s-i-1+1]; 
        }
        
        int l = 0, r = 0, ans = s;
        for (int i = -1; i < s; i++) {
            l = i == -1 ? 0 : left[i];
            r = i == s-1 ? 0 : right[i+1];
            ans = min(ans, l+r);
        }
        return ans;
    }
};
```

# number of longest increasing subsequence
**动归求长度，同时记录到达每个位置的种类***
``` cpp
class Solution {
public:
    int findNumberOfLIS(vector<int>& nums) {
        if (nums.empty()) return 0;
        
        vector<pair<int, int>> dp(nums.size(), {1, 1});
        int ans = 1, m = 0;
        
        for (int i = 0; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    if (dp[j].first >= dp[i].first) {
                        dp[i].first = dp[j].first + 1;
                        dp[i].second = dp[j].second;
                    } else if (dp[j].first + 1 == dp[i].first) {
                        dp[i].second += dp[j].second;
                    }
                }
            }
            
            if (dp[i].first == m) ans += dp[i].second;
            
            if (m < dp[i].first) {
                m = dp[i].first;
                ans = dp[i].second;
            }
        }

        return ans;
    }
};
```

# delete operation for two strings

**题目描述：**求两个字符串最少删除多少个可以变为一样的字符串
**思路：**最长公共子序列问题

``` cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        if (word1.empty() || word2.empty()) return word1.size() + word2.size();
        int s1 = word1.size(), s2 = word2.size();
        vector<vector<int>> dp(s1, vector<int>(s2));
        dp[0][0] = word1[0] == word2[0] ? 1 : 0;
        for (int j = 1; j < s2; j++) {
            dp[0][j] = (word1[0] == word2[j] ? 1 : dp[0][j-1]);
        }
        for (int i = 1; i < s1; i++) {
            dp[i][0] = (word1[i] == word2[0] ? 1 : dp[i-1][0]);
        }
        for (int i = 1; i < s1; i++) {
            for (int j = 1; j < s2; j++) {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                if (word1[i] == word2[j]) {
                    dp[i][j] = max(dp[i][j], dp[i-1][j-1] + 1);
                }
            }
        }
        int ans = dp[s1-1][s2-1];
        
        return s1 + s2 - 2*ans;
    }
};
```

# length of longest fibonacci subsequence
**思路：动态规划**

- dp[i, j]表示以j结尾，上一个fibonacci数字为i对应的满足fibonacci长度
- dp[i, j] = A[j] - A[i] < j ? dp[index(A[j]-A[i]),i]+1 : 2

``` cpp
class Solution {
public:
    int lenLongestFibSubseq(vector<int>& A) {
        int len = A.size();
        vector<vector<int>> dp(len, vector<int>(len));
        unordered_map<int, int> m;
        int ans = 0;
        for (int i = 0; i < len; i++) {
            m[A[i]] = i;
            
            for (int j = 0; j < i; j++) {
                int d = A[i] - A[j];
                
                if (m.find(d) != m.end()) {
                    int k = m[d];
                    dp[j][i] = d < A[j] ? dp[k][j] + 1 : 2;
                    ans = max(ans, dp[j][i]);
                } else {
                    dp[j][i] = 2;
                }
            }
        }
        return ans > 2 ? ans : 0;
    }
};
```

# stickers to spell word
**思路：采用自顶向下的dp方式**

``` cpp
class Solution {
public:
    int minStickers(vector<string>& stickers, string target) {
        vector<vector<int>> s(stickers.size(), vector<int>(26, 0));
        unordered_map<string, int> dp;
        int len = 0;
        for (auto& str : stickers) {
            for (auto& ch: str) s[len][ch-'a']++; 
            len++;
        }
        return helper(s, dp, target);
    }
    
    int helper(const vector<vector<int>>& s, unordered_map<string, int>& dp, string target) {
        if (target.empty()) return 0;
        if (dp.count(target)) return dp[target];
        vector<int> t(26);
        for (auto& ch : target) t[ch-'a']++;
        int len = s.size(), ans = INT_MAX;
        for (int i = 0; i < len; i++) {
            if (s[i][target[0]-'a'] == 0) continue;
            string str;
            for (int j = 0; j < 26; j++) {
                if (t[j]-s[i][j] > 0) str += string(t[j]-s[i][j], 'a'+j);   
            }
            int tmp = helper(s, dp, str);
            if (tmp != -1) ans = min(ans, 1+tmp);
        }
        dp[target] = ans == INT_MAX ? -1 : ans;
        return dp[target];
    }
};
```

# minimum cost for tickets
**思路：采用动态规划方式**
- dp[i] = min(dp[i-1] + cost[0], dp[i-7] + cost[1], dp[i-30] + cost[2])

``` cpp
class Solution {
public:
    int mincostTickets(vector<int>& days, vector<int>& costs) {
        //dp.resize(days.size());
        //return dfs(days, costs, 0);
        return DP(days, costs);
    }
    
    int dfs(const vector<int>& days, const vector<int>& costs, int i) {
        if (i >= days.size()) {
            return 0;
        }
        if (dp[i] != 0) return dp[i];
        int A = costs[0] + dfs(days, costs, lower_bound(days.begin(), days.end(), days[i]+1)-days.begin());
        int B = costs[1] + dfs(days, costs, lower_bound(days.begin(), days.end(), days[i]+7)-days.begin());
        int C = costs[2] + dfs(days, costs, lower_bound(days.begin(), days.end(), days[i]+30)-days.begin());
        
        dp[i] = min(min(A, B), C);
        return dp[i];
    }
    
    int DP(const vector<int>& days, const vector<int>& costs) {
        int lastDay = days[days.size()-1];
        dp.resize(lastDay+1, -1);
        for (auto& d : days) {
            dp[d] = 0;
        }
        dp[0] = 0;
        for (int i = 1; i <= lastDay; i++) {
            if (dp[i] == -1) { 
                dp[i] = dp[i-1];
                continue;
            }
            dp[i] = dp[i-1] + costs[0];
            dp[i] = min(dp[i], dp[max(i-7, 0)] + costs[1]);
            dp[i] = min(dp[i], dp[max(i-30, 0)] + costs[2]);
        }
        
        return dp[lastDay];
    }
    
    vector<int> dp;
};
```

# ones and zeroes
```
Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
Output: 4

Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”
```

**思路：动态规划**

- 首先将strs转换为ascii码的dictionary，然后进行自顶向下的动归，选或不选当前str
- 动归公式：dp[i] [j] [k] = max(dp[i-1] [j-dic[i] [0]] [k-dic[i] [1]] + 1, dp[i] [j] [k])
``` cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        int len = strs.size();
        vector<vector<int>> dic(len, {0, 0});
        
        for (int i = 0; i < len; i++) {
            for (auto& ch : strs[i]) {
                dic[i][ch-'0']++;
            }
        }
        return DP(dic, m, n);
        //dp.resize(len, vector<vector<int>>(m+1, vector<int>(n+1, -1)));
        //return helper(dic, m, n, 0);
    }
    
    int helper(const vector<vector<int>>& dic, int m, int n, int i) {
        if (i >= dic.size()) return 0;
        if (dp[i][m][n] != -1) return dp[i][m][n];
        int ans = INT_MIN;
        if (m - dic[i][0] >= 0 && n - dic[i][1] >= 0) ans =helper(dic, m-dic[i][0], n-dic[i][1], i+1)+1;
        ans = max(ans, helper(dic, m, n, i+1));
        dp[i][m][n] = ans;
        return ans;
    }
    
    int DP(const vector<vector<int>>& dic, int m, int n) {
        int len = dic.size();
        vector<vector<int>> memo(m+1, vector<int>(n+1));
        for (int i = 0; i < len; i++) {
            for (int j = m; j >= dic[i][0]; j--) {
                for (int k = n; k >= dic[i][1]; k--) {
                    memo[j][k] = max(memo[j][k], memo[j-dic[i][0]][k-dic[i][1]]+1);
                }
            }
        }
        return memo[m][n];
    }
    
    vector<vector<vector<int>>> dp;
};
```

# longest string chain
**思路：采用动态规划**
- 先对words进行排序
- dp[i] = max(m, dp[j]+1)
``` cpp
class Solution {
public:
    int longestStrChain(vector<string>& words) {
        sort(words.begin(), words.end(), [](string& i, string& j){return i.size() < j.size();});
        int len = words.size();
        auto comp = [](auto& lhs, auto& rhs) -> bool {
            if (lhs.size() != rhs.size()-1) return false;
            int diff = 0, i = 0, j = 0; ;
            while (i < lhs.size() && j < rhs.size()) {
                if (lhs[i] != rhs[j]) {
                    j++;
                    diff++;
                } else {
                    i++;
                    j++;
                }
                if (diff > 1) return false;
            }
            return true;
        };
        vector<int> dp(len, 1);
        int ans = INT_MIN;
        for (int i = 0; i < len; i++) {
            int m = 1;
            for (int j = 0; j < i; j++) {
                if (comp(words[j], words[i])) m = max(m, dp[j]+1);
            }
            dp[i] = m;
            ans = max(dp[i], ans);
        }
        return ans;
    }
};
```

# last stone weight ii
``` cpp
Each turn, we choose any two rocks and smash them together.  Suppose the stones have weights x and y with x <= y.  The result of this smash is:

If x == y, both stones are totally destroyed;
If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.
```
**动态规划解决**
``` cpp
// i1 - j1, i2 - j2, i3 - j3
// i1 - j1 - (i2 - j2), i3 - j3
// i1 - j1 - (i2 - j2) - (i3 - j3)
// i1 - i2 - i3 - j1 + j2 + j3
// 变成背包问题，不过相比简单背包的取或不取，这里变成了加或减
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        //return helper(stones, 0, 0);
        return helper1(stones);
    }
    
    int helper(vector<int>& stones, int sum, int start) {
        if (start >= stones.size()) return sum;
        return min(helper(stones, abs(sum-stones[start]), start+1), helper(stones, sum+stones[start], start+1));
    }
    
    int helper1(vector<int>& stones) {
        unordered_set<int> s1 = {0};
        for (auto& i : stones) {
            unordered_set<int> s2;
            for (auto& s : s1) {
                s2.insert(s-i);
                s2.insert(s+i);
            }
            swap(s2, s1);
        }
        int ans = INT_MAX;
        for (auto& s : s1) ans = min(ans, abs(s));
        return ans;
    }
};
```

# largest sum of averages
**思路：采用动态规划**
- dp[k] [i] = max(dp[k] [i], dp[k-1] [j] + (sum[i]-sum[j])/(i-j))
``` cpp
class Solution {
public:
    // dp[k][i] = max(dp[k][i], dp[k-1][j] + (sum[i]-sum[j])/(i-j))
    double largestSumOfAverages(vector<int>& A, int K) {
        int len = A.size();
        vector<vector<double>> dp(K+1, vector<double>(len+1));
        vector<int> sum(len+1);
        
        for (int i = 0; i < len; i++) sum[i+1] = (sum[i]+A[i]);
        for (int i = 1; i <= len; i++) dp[1][i] = (1.0 * sum[i])/i;
        
        for (int k = 2; k <= K; k++) {
            for (int i = 0; i <= len; i++) {
                for (int j = 1; j < i; j++) {
                    dp[k][i] = max(dp[k][i], dp[k-1][j]+1.0*(sum[i]-sum[j])/(i-j));
                }
            }
        }
        return dp[K][len];
    }
};
```

# maximum length of pair chain
**思路：动态规划**
- dp[i] = dp[j] + 1;

```cpp
class Solution1 {
public:
    int findLongestChain(vector<vector<int>>& pairs) {
        sort(pairs.begin(), pairs.end(), [](auto& lhs, auto& rhs){return lhs[0] < rhs[0];});
        auto comp = [](auto& lhs, auto& rhs) -> bool {return lhs[1] < rhs[0];};
        int len = pairs.size();
        vector<int> dp(len, 1);
        int ans = INT_MIN;
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < i; j++) {
                if (comp(pairs[j], pairs[i])) dp[i] = max(dp[i], dp[j] + 1);
            }
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
```

**思路：贪心算法**
- 贪心，按照second排序

``` cpp
class Solution {
public:
    int findLongestChain(vector<vector<int>>& pairs) {
        sort(pairs.begin(), pairs.end(), [](auto& lhs, auto& rhs){return lhs[1] < rhs[1];});
        auto comp = [](auto& lhs, auto& rhs) -> bool {return lhs[1] < rhs[0];};
        int len = pairs.size();
        int ans = 1;
        for (int next = 1, cur = 0; next < len; next++) {
            if (comp(pairs[cur], pairs[next])) {
                cur = next;
                ans++;
            }

        }
        return ans;
    }
};
```

****

# longest arithmetic sequence
**思路：动态规划，与最长递增子序列类似**
```cpp
class Solution {
public:
    int longestArithSeqLength(vector<int>& A) {
        unordered_map<int, unordered_map<int, int>> dp;
        int len = A.size(), ans = INT_MIN;
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < i; j++) {
                int d = A[i] - A[j];
                if (dp[d].count(j)) {
                    dp[d][i] = dp[d][j] + 1;
                } else {
                    dp[d][i] = 2;
                }
                ans = max(ans, dp[d][i]);
            }
        }
        return ans;
    }
};
```

# partition array for maximum sum
- dp[i] 标识i位置前K个的最大sum
- dp[i] = dp[i-j] + max(A[i], ..., A[i-k])*k  k-->[0, K-1]
- 求每个位置的最大值即可，典型的动态规划

``` cpp
class Solution {
public:
    int maxSumAfterPartitioning(vector<int>& A, int K) {
        int len = A.size();
        vector<int> dp(len + 1);
        
        for (int i = 0; i < len; i++) {
            int m = A[i];
            for (int j = 0; j < K && i+1-(j+1) >= 0; j++) {
                m = max(m, A[i-j]);
                dp[i+1] = max(dp[i+1], dp[i+1-(j+1)]+m*(j+1));
            }
        }
        return dp[len];
    }
};
```

#  Best Time to Buy and Sell Stock
``` cpp
Say you have an array for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.
Note that you cannot sell a stock before you buy one.

Example 1:
Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.Not 7-1 = 6, as selling price needs to be larger than buying price.

Example 2:
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
```

**只能买一次，所以只需要记录此前的最小价格即可了**

``` cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int minPrice = INT_MAX;
        int maxProfit = 0;
        for (auto price : prices) {
            if (price - minPrice > maxProfit) {
                maxProfit = price-minPrice;
            } else if (minPrice > price) {
                minPrice = price;
            }
        }
        return maxProfit;
    }
};
```

 # best time to buy and sekk stock III
** 限制：<br> 1. 最多买入两次 <br> 2. 第二次交易必须在第一次交易之后 **

``` cpp
Input: [3,3,5,0,0,3,1,4] Output: 6
Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. 
Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.
```

- 暴力求解方式，时间复杂度为O(n^4)，超时。
  - 每次求得以start1为开始最大利润，以end1结束
  - 以end1+1作为start2，求得最大利润，以end2结束
  - 迭代求解得到最大值
``` cpp
class Solution {
public:
	int maxProfit(vector<int>& prices) {
		if (prices.empty()) { return 0; }

		int start1 = 0, end1 = 1;
		int start2 = 2, end2 = 3;

		int maxProfit = 0;

		for (start1 = 0; start1 < prices.size() - 1; start1++) {
			for (end1 = start1 + 1; end1 < prices.size(); end1++) {
				if (prices[end1] - prices[start1] <= 0) {
					continue;
				}
				if (maxProfit < prices[end1] - prices[start1]) {
					maxProfit = prices[end1] - prices[start1];
				}
				for (start2 = end1 + 1; start2 < prices.size(); start2++) {
					for (end2 = start2 + 1; end2 < prices.size(); end2++) {
						if (prices[end2] - prices[start2] <= 0) {
							continue;
						}
						if (maxProfit < prices[end1] - prices[start1] + prices[end2] - prices[start2]) {
							maxProfit = prices[end1] - prices[start1] + prices[end2] - prices[start2];
						}

					}
				}
			}
		}
		return maxProfit;
	}
}
```

- 动态规划优化求解
  - 可以以O(n)的时间复杂度求得每个位置的最大利润
  - 可以以O(n^2)的时间复杂度求得某个位置之后的最大利润
  - 时间复杂度瞬间可以降低至O(n^2)

** dp[k][i]表示第k次交易在i卖出的最大利润，容易得到dp[k][i] = dp[k][i-1], prices[i]-prices[j]+dp[k-1][j-1] (j:[0, i] ) **

``` cpp
class Solution {
public:
	int maxProfit(vector<int>& prices) {
		vector<vector<int>> dp(2);
		for (auto& vec : dp) {
			vec.resize(prices.size());
		}
		int minPrice = INT_MAX, maxProfit = INT_MIN;
		for (int i = 0; i < prices.size(); ++i) {
			minPrice = std::min(prices[i], minPrice);
			maxProfit = std::min(maxProfit, prices[i]-minPrice);
			dp[0][i] = prices[i] - minPrice;
		}
		
		int maxK = INT_MIN;
		for (int z = 1; z < 2; z++) {
			for (int i = 1; i < prices.size(); ++i) {
				minPrice = prices[i];
				for (int j = 1; j <= i; j++) {
					minPrice = min(minPrice, prices[j]-dp[z-1][j-1]);
				}
				dp[z][i] = std::max(dp[z][i-1], prices[i] - minPrice);
			}
		}
		return dp[2 - 1][prices.size() - 1];
	}
};
```

- 上述动归方案还有可以优化的空间，min的计算是重复的
``` cpp
class Solution {
public:
	int maxProfit(vector<int>& prices) {
		vector<vector<int>> dp(2);
		for (auto& vec : dp) {
			vec.resize(prices.size());
		}
		int minPrice = INT_MAX;
		for (int i = 0; i < prices.size(); ++i) {
			minPrice = std::min(prices[i], minPrice);
			maxProfit = std::min(maxProfit, prices[i]-minPrice);
			dp[0][i] = prices[i] - minPrice;
		}
		
		int maxK = INT_MIN;
		for (int z = 1; z < 2; z++) {
		  minPrice = prices[0];
			for (int i = 1; i < prices.size(); ++i) {
				minPrice = min(minPrice, prices[i]-dp[z-1][i-1]);
				dp[z][i] = std::max(dp[z][i-1], prices[i] - minPrice);
			}
		}
		return dp[2 - 1][prices.size() - 1];
	}
};
```

# best time to buy and sell stock IV
``` cpp
Example 1:

Input: [2,4,1], k = 2
Output: 2
Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.
Example 2:

Input: [3,2,6,5,0,3], k = 2
Output: 7
Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.
             Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
```

** dp公式：dp[k][i] = std::max(dp[k][i-1], price[i]-min+dp[k-1][i-1] **
- 优化了空间复杂度，需要注意的是** dp[k][i]依赖于dp[k-1][i-1]，所以优化空间的时候要改变计算顺序 **

``` cpp
class Solution {
public:
    
    // dp[k][i] 第k次选择在第i次卖出的最大利润
    // dp[k][i] = std::min(dp[k-1][i], prices[i] - prices[j] + dp[k-1][j-1]);
    // prices[i] - prices[j] + dp[k-1][j-1] = prices[i] - (prices[j] - dp[k-1][j-1])
    // prices[j] - dp[k-1][j-1]最小即可
    int maxProfit(int k, vector<int>& prices) {
        if (prices.empty()) return 0;
        if (k >= prices.size()/2) {
            int sum = 0;
            for (int i = 1; i < prices.size(); i++) {
                sum += std::max(0, prices[i]-prices[i-1]);
            }
            return sum;
        }
        vector<int> dp(k+1);
        vector<int> min(k+1, prices[0]);
        for (int i = 1; i < prices.size(); i++) {
            for (int j = 1; j <= k; j++) {
                min[j] = std::min(min[j], prices[i] - dp[j-1]);
                dp[j] = std::max(dp[j], prices[i] - min[j]);
            }
        }
        return dp[k];
    }
};
```

# best time to buy and sell stock with cooldown

**思路：动态规划**
- 第i天能不能购买stock取决于第i-1天干了啥
- 第i天出售stock能获取的最大利润为max(buy[i-1]+prices[i], sell[i-1])
- 如果第i-1天进行了购买或出售操作，那么第i天只能rest

**转移方程**
- buy[i] = max(rest[i-1]-prices[i], buy[i-1]) 表示第i天及以前购买股票以后获取的最大利润，第i-1天没有进行操作才能购买第i天的股票
- sell[i] = max(buy[i-1]+prices[i], sell[i-1]) 表示第i天以及第i天以前出售股票能够获取的最大利润，第i天能否出售股票取决于第i天以前是否购买了股票
- reset[i] = max(buy[i-1], sell[i-1], rest[i-1]) 表示第i天啥也不干能够获取的最大利润

``` cpp
class Solution {
public:
	int maxProfit(vector<int>& prices) {
        if (prices.empty()) return 0;
		int size = prices.size();
		vector<int> buy(size, 0);
		vector<int> sell(size, 0);
		vector<int> rest(size, 0);

		buy[0] = -prices[0];

		for (int i = 1; i < size; i++) {
			buy[i] = std::max(rest[i - 1] - prices[i], buy[i - 1]);
			sell[i] = std::max(buy[i - 1] + prices[i], sell[i - 1]);
			rest[i] = std::max(buy[i - 1], std::max(sell[i - 1], rest[i - 1]));
		}
		return sell[size - 1];
	}
};
```

# best time to buy and sell stock with transaction fee
**思路：动态规划，因为可以买不限次数，所以每天的状态只有两种：买入或卖出**
- buy[i] = max(but[i-1], sell[i-1]-prices[i]-fee)
- sell[i] = max(sell[i-1], buy[i-1]+prices[i])
``` cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        if (prices.size() <= 1) return 0;
        vector<int> buy(prices.size());
        vector<int> sell(prices.size());
        buy[0] = -prices[0]-fee;
        
        for (int i = 1; i < prices.size(); i++) {
            buy[i] = max(buy[i-1], sell[i-1]-prices[i]-fee);
            sell[i] = max(sell[i-1], buy[i-1]+prices[i]);
        }
        
        return sell[prices.size()-1];
    }
};
```

# minimum swaps to make sequences increasing

**思路：暴力枚举解决，TLE**
``` cpp
class Solution {
public:
    int minSwap(vector<int>& A, vector<int>& B) {
        return helper(A, B, 0, 0);
    }
    bool is_sorted(vector<int>& A) {
        if (A.empty()) return false;
        for (int i = 1; i < A.size(); i++) if (A[i-1] >= A[i]) return false;
        return true;
    }
    int helper(vector<int>& A, vector<int>& B, int i, int cur) {
        if (i == A.size()) {
            if (is_sorted(A) && is_sorted(B)) return cur;
            return INT_MAX;
        }
        int m = helper(A, B, i+1, cur);
        swap(A[i], B[i]);
        m = min(m, helper(A, B, i+1, cur+1));        
        swap(A[i], B[i]);
        return m;
    }
};
```

**思路：动态规划**

```
class Solution {
public:
    int minSwap(vector<int>& A, vector<int>& B) {
        int len = A.size();
        vector<int> swapped(len, 1);
        vector<int> not_swapped(len);
        
        for (int i = 1; i < len; i++) {
            swapped[i] = not_swapped[i] = len;
            if (A[i-1] < A[i] && B[i-1] < B[i]) {
                swapped[i] = swapped[i-1]+1;
                not_swapped[i] = not_swapped[i-1];
            }
            
            if (A[i-1] < B[i] && B[i-1] < A[i]) {
                swapped[i] = min(swapped[i], not_swapped[i-1]+1);
                not_swapped[i] = min(not_swapped[i], swapped[i-1]);
            }
        }
        return min(swapped[len-1], not_swapped[len-1]);
    }
};
```

# maximum length of repeated subarrays
**思路：Burst force**

``` cpp
class Solution1 {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        int ans = INT_MIN;
        int len1 = A.size(), len2 = B.size();
        
        for (int i = 0; i < len1; i++) {
            for (int j = 0; j < len2; j++) {
                int k = 0;
                while (i + k < len1 && j + k < len2 && A[i+k] == B[j+k]) k++;
                ans = max(ans, k);
            }
        }
        return ans;
    }
};
```

**思路：dp**
``` cpp
class Solution2 {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        int ans = INT_MIN;
        int len1 = A.size(), len2 = B.size();
        vector<vector<int>> dp(len1+1, vector<int>(len2+1));
        for (int i = 1; i <= len1; i++) {
            for (int j = 1; j <= len2; j++) {
                if (B[j-1] == A[i-1]) dp[i][j] = dp[i-1][j-1] + 1;
                ans = max(dp[i][j], ans);
            }
        }
        return ans;
    }
};
```

**思路：优化空间dp**
``` cpp
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        int ans = INT_MIN;
        int len1 = A.size(), len2 = B.size();
        vector<int> dp(len1+1);
        for (int i = 1; i <= len1; i++) {
            for (int j = len2; j >= 1; j--) {
                if (B[j-1] == A[i-1]) dp[j] = dp[j-1] + 1;
                else {
                    dp[j] = 0;
                }
                ans = max(dp[j], ans);
            }
        }
        return ans;
    }
};
```

# different ways to add parenthess
``` cpp
Example 1:

Input: "2-1-1"
Output: [0, 2]
Explanation: 
((2-1)-1) = 0 
(2-(1-1)) = 2
Example 2:

Input: "2*3-4*5"
Output: [-34, -14, -10, -10, 10]
Explanation: 
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
```

**思路：递归解决，遇见操作符，则分治运算解决**

``` cpp
class Solution {
public:
    vector<int> diffWaysToCompute(string input) {
        vector<int> ans;
        int len = input.size();
        for (int i = 0; i < len; i++) {
            char cur = input[i];
            if (cur == '+' || cur == '-' || cur == '*') {
                vector<int> ans1 = diffWaysToCompute(input.substr(0, i));
                vector<int> ans2 = diffWaysToCompute(input.substr(i+1));
                
                for (int j : ans1) {
                    for (int k : ans2) {
                        if (cur == '+') {
                            ans.push_back(j+k);
                        } else if (cur == '-') {
                            ans.push_back(j-k);
                        } else {
                            ans.push_back(j*k);
                        }
                    }
                }
            }
        }
        if (ans.empty()) {
            ans.push_back(atoi(input.c_str()));
        }
        return ans;
    }
};
```

# knight dialer

**思路1：burst force  TLE**
``` cpp
class Solution {
public:
    int knightDialer(int N) { 
        int ans = 0;
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 3; j++) {
                ans += paths(i, j, N);
            }
        }
        return ans;
    }
    
    int paths(int i, int j, int n) {
        if (i < 0 || j >= 3 || i >= 4 || j < 0 || (i == 3 && j != 1)) return 0;
        if (n == 1) return 1;
        int ans = paths(i-2, j-1, n-1) +
                  paths(i+2, j-1, n-1) + 
                  paths(i-1, j-2, n-1) +
                  paths(i+1, j-2, n-1) +
                  paths(i-2, j+1, n-1) +
                  paths(i+2, j+1, n-1) + 
                  paths(i-1, j+2, n-1) +
                  paths(i+1, j+2, n-1);
        return ans;
    }
};
```

**思路2：动态规划，自底向上 **

```
class Solution {
public:
    int knightDialer(int N) { 
        long long ans = 0;
        dp.resize(N, vector<long long>(10, 1));
        vector<vector<int>> moves = {{4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4}};
        for (int n = 1; n < N; n++) {
            for (int i = 0; i < 10; i++) {
                dp[n][i] = 0;
                for (int j : moves[i]) {
                    dp[n][i] += dp[n-1][j]; dp[n][i] %= mod;                        
                }
            }
        }
        for (int i = 0; i < 10; i++) {
            ans += dp[N-1][i]; ans %= mod;
        }
        return ans;
    }
    
    vector<vector<long long>> dp;
    const int mod = 1000000007;
};
```

# minimum score trianguation
**思路：动态规划解决      dp[i, j] = dp[i, k] + dp[k, j] + [i mul k mul j]**
``` cpp
class Solution {
public:

    int minScoreTriangulation(vector<int>& A) {
        int N = A.size();
        vector<vector<int>> dp(N, vector<int>(N, 0));
        
        for (int d = 2; d < N; d++) {
            for (int i = 0; i + d < N; i++) {
                int j = i + d;
                dp[i][j] = INT_MAX;
                for (int k = i+1; k < j; k++) {
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + A[i]*A[j]*A[k]);
                }
            }
        }
        return dp[0][N-1];
    }
};
```

# can i win
**思路：采用自顶向下的动态规划**
``` cpp
class Solution {
public:
    bool canIWin(int maxChoosableInteger, int desiredTotal) {
        if(desiredTotal <= 0) return true;
        int sum = (1+maxChoosableInteger)*maxChoosableInteger/2;
        if(sum < desiredTotal) return false;
        if(desiredTotal <= 0) return true;
        used.resize(maxChoosableInteger+1, 0);
        return helper(desiredTotal);
    }
    
    bool helper(int desiredTotal) {
        if (desiredTotal <= 0) return false;
        int key = format();
        if (m.count(key)) return m[key];
        for (int i = 1; i < used.size(); i++) {
            if (used[i] == 1) continue;
            used[i] = 1;
            if (!helper(desiredTotal-i)) {
                used[i] = 0;
                m[key] = true;
                return true;
            }
            used[i] = 0;
        }
        m[key] = false;
        return false;
    }
    
    int format() {
        int num = 0;
        for (auto& u : used) {
            num <<= 1;
            if (u == 1) num |= 1;
        }
        return num;
    }
    
    vector<int> used;
    unordered_map<int, bool> m;
};
```