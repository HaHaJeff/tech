# find all duplicate in an array
**思路：将当前num当作下标，并将该num下标对应的值变为负数，如果再次遍历同样的num，那么如果该num下标对应的值为负，则说明重复**
``` cpp
class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> ans;
        for (auto& n : nums) {
            nums[abs(n)-1] = -nums[abs(n)-1];
            if (nums[abs(n)-1] > 0) ans.push_back(abs(n));
        }
        return ans;
    }
};
```

# find all numbers disappeared in an array

**思路：将num当作下标，如果num下标处对应的值小于0，则不变负，否则变为负值，最后再次遍历该数组，如果i下标处对应的值大于0，说明数字缺失**

``` cpp
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        vector<int> ans;
        
        for (auto& n : nums) {
            nums[abs(n)-1] = nums[abs(n)-1] < 0 ? nums[abs(n)-1] : nums[abs(n)-1]*-1;
        }
        
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0) ans.push_back(i+1);
        }
        
        return ans;
    }
};
```

# next permutation

**思路：找到第一个大于当前序列的下一个序列**
- 从后往前找，找到nums[i] <= nums[i+1]的第一个i，i表示需要被替换的第一个位置
- 从后往前找，找到nums[j] >= nums[i]的第一个j，j表示i需要替换的值
- 交换[i, j]
- 逆序[i+1,end]，因为[i+1, end]是i位置被交换过以后的最大序列

``` cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i = nums.size() - 2;
        
        while (i >= 0 && nums[i] >= nums[i+1]) i--;
        
        if (i >= 0) {
            int j = nums.size() - 1;
            while (j >= 0 && nums[j] <= nums[i]) j--;
            swap(nums[i],nums[j]);
        }
        reverse(nums.begin()+i+1, nums.end());
    }
};
```

# pairs of song with total durations divisible by 60

**思路：(x+y)%60=0 ==> (x%60 + y%60)%60 = 0**
- 遇见x的时候，需要查找是否存在y，可以采用容器将y%60记录下来
- y=(60-x%60)%60
- x, y >= 1

``` cpp
class Solution {
public:
    int numPairsDivisibleBy60(vector<int>& time) {
        vector<int> vec(60);
        int res = 0;
        for (auto& t : time) {
            res += vec[(60-t%60)%60];
            vec[t%60] += 1;
        }
        return res;
    }
};
```