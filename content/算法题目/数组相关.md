# find all duplicate in an array
**思路：将当前num当作下标，并将该num下标对应的值变为负数，如果再次遍历同样的num，那么如果该num下标对应的值为负，则说明重复**
``` cpp
class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> ans;
        for (auto& n : nums) {
            nums[abs(n)-1] = -nums[abs(n)-1];
            if (nums[abs(n)-1] > 0) ans.push_back(abs(n));
        }
        return ans;
    }
};
```

# find all numbers disappeared in an array

**思路：将num当作下标，如果num下标处对应的值小于0，则不变负，否则变为负值，最后再次遍历该数组，如果i下标处对应的值大于0，说明数字缺失**

``` cpp
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        vector<int> ans;
        
        for (auto& n : nums) {
            nums[abs(n)-1] = nums[abs(n)-1] < 0 ? nums[abs(n)-1] : nums[abs(n)-1]*-1;
        }
        
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0) ans.push_back(i+1);
        }
        
        return ans;
    }
};
```

# next permutation

**思路：找到第一个大于当前序列的下一个序列**
- 从后往前找，找到nums[i] <= nums[i+1]的第一个i，i表示需要被替换的第一个位置
- 从后往前找，找到nums[j] >= nums[i]的第一个j，j表示i需要替换的值
- 交换[i, j]
- 逆序[i+1,end]，因为[i+1, end]是i位置被交换过以后的最大序列

``` cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i = nums.size() - 2;
        
        while (i >= 0 && nums[i] >= nums[i+1]) i--;
        
        if (i >= 0) {
            int j = nums.size() - 1;
            while (j >= 0 && nums[j] <= nums[i]) j--;
            swap(nums[i],nums[j]);
        }
        reverse(nums.begin()+i+1, nums.end());
    }
};
```

# pairs of song with total durations divisible by 60

**思路：(x+y)%60=0 ==> (x%60 + y%60)%60 = 0**
- 遇见x的时候，需要查找是否存在y，可以采用容器将y%60记录下来
- y=(60-x%60)%60
- x, y >= 1

``` cpp
class Solution {
public:
    int numPairsDivisibleBy60(vector<int>& time) {
        vector<int> vec(60);
        int res = 0;
        for (auto& t : time) {
            res += vec[(60-t%60)%60];
            vec[t%60] += 1;
        }
        return res;
    }
};
```

# search in rotated sorted array

``` cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size()-1, mid = 0;
        
        while (l <= r) {
            mid = l + (r-l)/2;
            
            if (nums[mid] == target) {
                return mid;
            }
            
            if (nums[mid] > nums[r]) {
               if (target < nums[mid] && target >= nums[l]) {
                   r = mid - 1;
               } else {
                   l = mid + 1;
               }
            } else if (nums[mid] < nums[l]) {
                if (target > nums[mid] && target <= nums[r]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            } else {
                if (target > nums[mid]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
            
        }
        return -1;
    }
};
```

# find minimum in rotated sorted in array ii

**思路:二分查找，数组中包含相同数字**
- 如何判断是不是旋转数组，nums[mid] > nums[r]  or nums[mid] < nums[l]，但是需要注意的是：如果nums[mid] < nums[l]，此时右边也是可以直接排除的
- 如果不是旋转数组，则mid右边的数组直接排除
- 如果是旋转数组，即nums[mid] > nums[r]，则最小数字出现在右端
- 如果nums[mid] == nums[r]，此时没有办法直接派出，只能采用r--

``` cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int lo = 0, hi = nums.size()-1;
        int mid = 0;
        while (lo < hi) {
            mid = lo + ((hi-lo)>>1);
            if (nums[mid] > nums[hi]) lo = mid+1;
            else if (nums[mid] < nums[hi]) hi = mid;
            else hi--;
            std::cout << lo << " " << mid << " " << hi << std::endl;
        }
        return nums[lo];   
    }
};
```

# subarray sum equal k
``` cpp
// 滑动窗口只可以处理正数，不能处理负数
class Solution1 {
public:
    int subarraySum(vector<int>& nums, int k) {
        int left = 0, right = 0, sum = 0, cnt = 0;
        int s = nums.size();
        while (right < s) {
            sum += nums[right];
            while (sum >= k && left <= right) {
                if (sum == k) cnt++;
                sum -= nums[left++];
            }
            ++right;
        }
        return cnt;
    }
};

// 思路：只要preSum[i] - preSum[j] == k，则说明[i, j]内的subarray = k
class Solution2 {
public:
    int subarraySum(vector<int>& nums, int k) {
        int cnt = 0;
        vector<int> preSum(nums.size()+1);
        preSum[0] = 0;
        for (int i = 1; i <= nums.size(); i++) preSum[i] = preSum[i-1] + nums[i-1];
        
        for (int i = 0; i < nums.size(); i++) {
            for (int j = i+1; j <= nums.size(); j++) {
                if (preSum[j]-preSum[i] == k) cnt++;
            }
        }
        return cnt;
    }
};

// 思路：记录当前位置之前的前缀和
// 如果当前位置sum-之前某个位置的sum==k，即满足条件
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int cnt = 0, sum = 0;
        unordered_map<int, int> m;
        m[0] = 1;
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
            cnt += m[sum-k];
            m[sum] += 1;
        }
        return cnt;
    }
};




```

# find pivot index

**思路：记录每个index的前缀和**

``` cpp
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int n = nums.size();
        vector<int> preSum(n+1);
        
        for(int i = 1; i <= n; i++) {
            preSum[i] = preSum[i-1]+nums[i-1];
        }
        for (int i = 0; i < n; i++) {
            if (preSum[i] == (preSum[n] - preSum[i+1]))
                return i;
        }
        return -1;
    }
};
```

# summary ranges

``` cpp
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        if (nums.empty()) return {};
        vector<string> results;
        int left = 0, right = 0;
        for (int i = 0; i < nums.size();) {
            left = right = i;
            while (right < nums.size() - 1 && nums[right+1] == nums[right]+1) right++;
            if (right > left) results.push_back(to_string(nums[left]) + "->" + to_string(nums[right]));
            else results.push_back(to_string(nums[left]));
            i = right + 1;
        }
        return results;
    }
};
```

# longest turbulent subarray

**思路：求最长锯齿形数组**
- 锯齿形数组即nums[i] < nums[i+1] && nums[i] > nums[i-1]
- 所以记录(nums[i] - nums[i-1]) * (nums[i] - nums[i+1]) < 0

``` cpp
class Solution {
public:
    int maxTurbulenceSize(vector<int>& A) {
        int len = A.size(), left = 0, right = 1;
        int c = 0, ans = 1;
        auto comp = [](int& l, int &r) -> int {return l < r ? -1 : l == r ? 0 : 1;};
        while (right < len) {
            int c = comp(A[right-1], A[right]);
            if (c == 0) {
                left = right;
            } else if (right == len-1 || c * comp(A[right], A[right+1]) != -1) {
                ans = max(ans, right - left + 1);
                left = right;
            }
            right++;
        }
        return ans;
    }
};
```

# slide window maximum

**思路：采用单调队列可以完成**

- 维护一个deque，头部表示目前窗口最大值的index，front的持续范围是：当i-k==front时，pop
- 每次轮询到nums[i]的时候，先判断i位置是否已经超过某个窗口，i-k==front，如果超过，pop
- 判断nums[i]是否比deque.back()位置对应的值大，num[i]和deque内的值此时一定在一个窗口内
  - 如果比back大，则说明back处的值可能不可能成为某个窗口的最大值，所以pop
  - 如果比back小，则push进去

``` cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int len = nums.size();
        deque<int> d;
        vector<int> results;
        for(int i = 0; i < len; i++) {
            if (!d.empty() && d.front() == i-k) d.pop_front();
            while (!d.empty() && nums[i] > nums[d.back()]) d.pop_back();
            d.push_back(i);
            if (i >= k-1) results.push_back(nums[d.front()]);
        }
        return results;
    }
};
```

# Count of smaller numbers after self

**思路：归并排序**

- 在merge的时候从后往前，对index对排序

  ```cpp
  class Solution {
  public:
    vector<int> countSmaller(vector<int>& nums) {
        ans.resize(nums.size());
        indice.resize(nums.size());
        for (int i = 0; i < ans.size(); i++) indice[i] = i;
        mergeSort(nums);
        return ans;
    }
  
    void mergeSort(vector<int>& nums) {
        merge(nums, 0, nums.size()-1);
    }
  
    void merge(vector<int>& nums, int l, int r) {
        if (l >= r) return;
  
        int mid = l + (r-l)/2;
  
        merge(nums, l, mid);
        merge(nums, mid + 1, r);
  
        vector<int> tmp(r-l+1);
  
        int k = r-l;
        int i = mid, j = r;
        while(k >= 0 && i >= l && j >= mid + 1) {
            int n = 0;
            if (nums[indice[i]] > nums[indice[j]]) {
                n = j - mid;
                ans[indice[i]] += n;
                tmp[k--] = indice[i--];
            }  else {
                tmp[k--] = indice[j--];
            }
        }
        while (k >= 0 && i >= l) {
            tmp[k--] = indice[i--];
        } 
        while (k >= 0 && j >= mid + 1) {
            tmp[k--] = indice[j--];
        }
        move(tmp.begin(), tmp.end(), indice.begin()+l);
    }
  
    vector<int> indice;
    vector<int> ans;
  };
  ```